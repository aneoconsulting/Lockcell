from .config.BaseConfig import BaseConfig
from pathlib import Path
from typing import Union
from .constants import USER_SCRIPTS_PATH


class ConfigVerrou(BaseConfig):
    """
    ConfigVerrou A config class that allow Verrou to run on an appropriate Docker (need to use the ... image on the partition)
    """

    def __init__(
        self,
        workingdir: Union[Path, str],
        RelrunPath: Union[Path, str],
        RelCmpPath: Union[Path, str],
    ):
        """
        Initialize the Verrou configuration by setting required binary paths.

        This constructor defines the working directory and relative paths to the
        `DD_RUN` and `DD_CMP` executables required by Verrou.

        Args:
            workingdir (Union[Path, str]): Path to the directory containing the `DD_RUN` and `DD_CMP` files.
            RelrunPath (Union[Path, str]): Relative path to `DD_RUN`, from `workingdir`.
            RelCmpPath (Union[Path, str]): Relative path to `DD_CMP`, from `workingdir`.

        Raises:
            TypeError: If any of the arguments cannot be converted to a `Path`
                (i.e., not a string or `Path` instance).
        """

        if isinstance(workingdir, str):
            workingdir = Path(workingdir)
        if isinstance(RelrunPath, str):
            RelrunPath = Path(RelrunPath)
        if isinstance(RelCmpPath, str):
            RelCmpPath = Path(RelCmpPath)

        if not isinstance(workingdir, Path):
            raise TypeError(f"workingdir must be of class Path, not {type(workingdir).__name__}")
        if not isinstance(RelrunPath, Path):
            raise TypeError(f"runPath must be of class Path, not {type(RelrunPath).__name__}")
        if not isinstance(RelCmpPath, Path):
            raise TypeError(f"CmpPath must be of class Path, not {type(RelCmpPath).__name__}")
        super().__init__(1)

        # Permet de travailler proprement dans le dossier reservé à cette config (existera dans tous les conteneurs)
        self.workdir = workingdir
        self.runPath = RelrunPath
        self.CmpPath = RelCmpPath

    def RunRefAndGenerateSource(self):
        """
        Performs the reference run and stores it in `workingdir/ref`.

        Also generates the `lignes.source` file in the working directory.

        Raises:
            RuntimeError: If the reference run fails.
        """

        import subprocess
        import os

        # Variables d’environnement pour le run de référence
        env = os.environ.copy()
        env["VERROU_ROUNDING_MODE"] = "nearest"
        env["VERROU_FLOAT"] = "no"
        env["VERROU_UNFUSED"] = "no"
        env["VERROU_MCA_MODE"] = "ieee"

        # Lancement de l’exécutable
        ref_result = subprocess.run(
            [
                "bash",
                USER_SCRIPTS_PATH + "/parse.sh",
                str(self.workdir),
                str(self.runPath),
            ],  # parse.sh prend un dossier qui contient un executable et génère le parsing des \
            stdout=subprocess.DEVNULL,
            stderr=subprocess.PIPE,
            env=env,  # lignes dans lignes.source et la configuration de référence dans ref/result.dat
            text=True,
        )

        # vérification de la bonne execution
        if ref_result.returncode != 0:
            raise RuntimeError(
                f"Error while executing the unperturbed reference run :\n {str(ref_result.stderr)}"
            )

    def generateSearchSpace(self) -> list:
        """
        Generates a search space from integers.

        Returns:
            list: The set of perturbable lines.

        Raises:
            FileNotFoundError: If the parsed lines file has not been generated by the RunRefAndGenerateSource method.
        """
        In = self.workdir / "lines.source"
        try:
            with open(In, "r") as file:
                all_lines = file.readlines()
        except FileNotFoundError:
            raise FileNotFoundError(
                "Cannot genrate a searchspace without the lines.source file, please call the RunRefAndGenerateSource method before generating searchspace"
            )

        return all_lines

    def __copy__(self) -> "ConfigVerrou":
        res = ConfigVerrou(self.workdir, self.runPath, self.CmpPath)
        res.nbRun = self.nbRun
        res.mode = self.mode
        return res

    def Test(self, subspace: list) -> bool:
        """
        Run a perturbed `DD_RUN` execution using the lines provided in `subspace`.

        Args:
            subspace (list): Line indices to perturb during the run.

        Raises:
            RuntimeError: If `DD_RUN` fails. The process stderr is attached to the exception.

        Returns:
            bool: Whether the test passes (True) or fails (False).
        """

        import os
        import subprocess

        # Folder to store the results, from the point of view inside workingdir
        # since DD_RUN and DD_CMP are executed there
        REF_DIR = str("ref")
        PERTURBED_DIR = str("pert")
        LIGNE_FICHIER = str("lines.pert")
        CURRENT = str(
            "./"
        )  # When running commands in the context of cd workdir, we use the current directory

        # Prepare the file containing the lines to perturb for Verrou
        fout = self.workdir / LIGNE_FICHIER
        with open(fout, "w") as f:
            f.writelines(subspace)

        # Define environment variables for the perturbed run
        env = os.environ.copy()
        env["VERROU_SOURCE"] = CURRENT + LIGNE_FICHIER
        env["VERROU_ROUNDING_MODE"] = "random"
        env["VERROU_FLOAT"] = "no"
        env["VERROU_UNFUSED"] = "no"
        env["VERROU_LIBM_NOINST_ROUNDING_MODE"] = "nearest"

        # Step 3 — Launch the perturbed run
        os.makedirs(str(self.workdir / PERTURBED_DIR), exist_ok=True)
        pert_result = subprocess.run(
            ["./" + str(self.runPath), CURRENT + PERTURBED_DIR],
            cwd=str(self.workdir),
            text=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.PIPE,
            env=env,
        )

        # TODO: Retrieve pert_result.stderr to process and return it
        if pert_result.returncode != 0:
            raise RuntimeError(
                f"Error during the exectution of DD_RUN :\n {str(pert_result.stderr)}"
            )

        # Step 4 — Compare with DD_CMP
        cmp_result = subprocess.run(
            ["./" + str(self.CmpPath), CURRENT + REF_DIR, CURRENT + PERTURBED_DIR],
            cwd=str(self.workdir),
        )

        # Global return code
        return cmp_result.returncode == 0
